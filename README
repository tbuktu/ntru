The NTRU Cryptosystem

  A Java implementation of the NTRU public-key cryptosystem, consisting of
  the encryption scheme NTRUEncrypt and the signature scheme NTRUSign.
  
  NTRU's main strengths are high performance and resistance to quantum
  computer attacks.
  NTRU keys are longer than ECC keys but shorter than RSA keys.
  
  http://en.wikipedia.org/wiki/NTRUEncrypt
  http://en.wikipedia.org/wiki/NTRUSign
  
  The implementation follows IEEE P1363.1 for NTRUEncrypt and the EESS
  (http://grouper.ieee.org/groups/1363/lattPK/submissions/EESS1v2.pdf)
  for NTRUSign.
  

NtruEncrypt Usage

  The first step is always to create an NtruEncrypt instance by calling the
  constructor with an EncryptionParameters object representing the desired
  algorithm parameters.
  It is recommended to use one of the predefined parameter sets which are
  available as constants in EncryptionParameters, but new ones can be created
  as well.
  
  After an NtruEncrypt instance has been created, it can be used to generate
  new key pairs, and encrypt / decrypt messages.
  
  Encrypting a message is done by calling encrypt() which takes the following
  parameters:

    1. the message itself as a byte array. Strings can be encrypted after
       converting them to byte[] via getBytes()
    2. an EncryptionPublicKey, which can be generated via
       NtruEncrypt.generateKeyPair() or an existing key can be reconstructed
       from a byte array by calling new EncryptionPublicKey(byte[])
  
  The encrypted message is returned as a byte array.

  Decrypting a message is done by calling decrypt() which takes the message,
  an EncryptionKeyPair containing the public and private keys, and the
  encryption parameters. The parameters used for decrypting must be the same
  as the ones used to encrypt the message; the same goes for the public key.

  Like all public-key encryption schemes, NtruEncrypt can only encrypt a
  limited number of characters. To encrypt larger amounts of data, use
  symmetric encryption and encrypt the symmetric key with NTRU (symmetric keys
  are well below the size limit). To find out how long a NTRU message can be,
  use the method EncryptionParameters.getMaxMessageLength().


NtruSign Usage
  
  The first step is always to create an NtruSign instance by calling the
  constructor with an SignatureParameters object representing the desired
  algorithm parameters.
  It is recommended to use one of the predefined parameter sets which are
  available as constants in SignatureParameters, but new ones can be created
  as well.
  
  After the NtruSign constructor is called, the NtruSign instance can be
  used to generate new key pairs, sign messages, and verify signatures.
  
  There are two ways of signing a message. It can be done in one step by
  calling sign(byte[], SignatureKeyPair) which takes the following parameters:

    1. the message itself as a byte array. Strings can be signed after
       converting them to byte[] via getBytes()
    2. a SignatureKeyPair, which can be generated via
       NtruSign.generateKeyPair() or an existing key pair can be reconstructed
       from a byte array using the SignaturePrivateKey(byte[]) and
       SignaturePublicKey(byte[]) constructors.
       Note: Depending on the parameters, it can take a minute or more to
       generate a new key pair.
  
  The signature is returned as a byte array.

  The other way is to call initSign with a SignatureKeyPair, then
  update(byte[]) zero or more times, and finally sign(byte[]). This way,
  long messages can be broken up rather than signing them in one piece.
  
  Just like signing, verifying a message can be done in one step or in several
  parts.
  The one-step variant works by calling NtruSign.verify() which takes the
  message, the signature, and the SignaturePublicKey. The parameters used for
  verifying must be the same as the ones used to create the signature; the
  same goes for the public key.
  The multi-step variant works by calling initSign with a SignaturePublicKey,
  then calling update(byte[]) zero or more times, and finally calling
  verify(byte[]).


Key Import / Export

  Encryption keys and signature keys can be written to a file via the writeTo
  methods by supplying a FileOutputStream. The key can then be read from the
  file by passing a FileInputStream to the appropriate constructor.
  
  Keys are encoded raw, so the array contains no information about the
  parameters used. It is advisable to first write the parameters, then the
  key. Parameters can be written to an OutputStream just like keys, and just
  like keys they have a constructor that takes an InputStream.

  Keys can also be converted to and from byte arrays.


Sample Programs

  The net.sf.ntru.demo package contains several small console programs:

  SimpleExample    A minimal example showing how to use NTRUEncrypt and
                   NTRUSign
  Benchmark        Benchmarks NTRUEncrypt against RSA and ECC
  Timings          Similar to Benchmark but only NTRUEncrypt and NTRUSign are
                   benchmarked, and the output is in table format.


Maven Artifact

  NTRU is available from the Maven central repository.

  <dependency>
    <groupId>net.sf.ntru</groupId>
    <artifactId>ntru</artifactId>
    <version>0.8</version>
  </dependency>


Further reading

  Original NTRUEncrypt paper: http://www.ntru.com/cryptolab/pdf/ANTS97.pdf
  Follow-up NTRUEncrypt paper: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.64.6834&rep=rep1&type=pdf
  Original NTRUSign paper: http://www.math.brown.edu/~jpipher/NTRUSign_RSA.pdf
  Follow-up NTRUSign paper: http://grouper.ieee.org/groups/1363/WorkingGroup/presentations/NTRUSignParams-2005-08.pdf
  NTRU articles (technical and mathematical): http://www.securityinnovation.com/cryptolab/articles.shtml
  Jeffrey Hoffstein et al: An Introduction to Mathematical Cryptography, Springer-Verlag, ISBN 978-0-387-77993-5
  EESS: http://grouper.ieee.org/groups/1363/lattPK/submissions/EESS1v2.pdf
